## ===========================================
## Email RAG Bot - Kubernetes Deployment Values
## ===========================================
## This file is used with your common-helmchart
## Deploy command: helm install email-rag ./common-helmchart -f k8s-values.yaml

## Application identity
nameOverride: ""
fullnameOverride: "email-rag-backend"
appLabels:
  app: email-rag
  component: backend

## Container image
## Build command: docker build --platform linux/amd64 -t amiteshhsingh/email-rag-backend:v1.0.1 ./backend
image:
  repository: amiteshhsingh/email-rag-backend
  tag: "v1.0.4"
  pullPolicy: IfNotPresent

# imagePullSecrets not needed for public Docker Hub images
# imagePullSecrets:
#   - name: regcred

## Deployment settings
replicaCount: 1  # Start with 1 for high availability
type: deployment
revisionHistoryLimit: 5

podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8000"
  prometheus.io/path: "/metrics"

podLabels:
  app: email-rag
  component: backend

annotations: {}

serviceAccount:
  create: true
  name: "email-rag-sa"
  annotations: {}

## Service Configuration
service:
  port: 8000
  targetPort: 8000
  protocol: TCP
  name: http
  annotations: {}

## Ingress Configuration
## Disabled for localhost/port-forwarding access
ingress:
  enabled: false
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/proxy-body-size: "5g"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "1200"  # 20 minutes for large file uploads
    nginx.ingress.kubernetes.io/proxy-send-timeout: "1200"  # 20 minutes
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "120"  # 2 minutes
    nginx.ingress.kubernetes.io/enable-cors: "true"
  hosts: []
  tls: []

## Persistence for uploads and ChromaDB data
## Uses shared PVC: email-rag-data (create with k8s-shared-pvc.yaml first)
persistence:
  enabled: true
  existingClaim: "email-rag-data"  # Use pre-created shared PVC
  mountPath: /app/data  # Mount at /app/data (contains uploads/ and chroma/ subdirs)
  storageClass: "nfs-csi"  # StorageClass (only used if existingClaim not found)
  accessMode: ReadWriteMany
  size: 10Gi

## Autoscaling
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 5
  targetCPUUtilizationPercentage: 75
  targetMemoryUtilizationPercentage: 80

## Pod Disruption Budget
pdb:
  minAvailable: 1

## Health checks
healthProbe:
  enabled: true
  path: /health
  port: 8000
  livenessProbe:
    initialDelaySeconds: 60
    periodSeconds: 15
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  readinessProbe:
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 3
    failureThreshold: 3
    successThreshold: 1
  startupProbe:
    initialDelaySeconds: 0
    periodSeconds: 10
    timeoutSeconds: 3
    failureThreshold: 30
    successThreshold: 1

terminationGracePeriodSeconds: 120  # Allow time for processing to finish

## Environment Variables
## IMPORTANT: Create a Kubernetes secret for sensitive values
env:
  - name: APP_ENV
    value: "production"
  - name: DATABASE_URL
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: database-url
  - name: REDIS_URL
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: redis-url
  - name: CELERY_BROKER_URL
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: celery-broker-url
  - name: SECRET_KEY
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: secret-key
  - name: JWT_SECRET_KEY
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: jwt-secret-key
  - name: OPENAI_API_KEY
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: openai-api-key
        optional: true
  - name: ANTHROPIC_API_KEY
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: anthropic-api-key
        optional: true
  - name: GOOGLE_API_KEY
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: google-api-key
        optional: true
  - name: XAI_API_KEY
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: xai-api-key
        optional: true
  - name: GROQ_API_KEY
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: groq-api-key
        optional: true
  - name: CEREBRAS_API_KEY
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: cerebras-api-key
        optional: true
  - name: CUSTOM_LLM_BASE_URL
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: custom-llm-base-url
        optional: true
  - name: CUSTOM_LLM_API_KEY
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: custom-llm-api-key
        optional: true
  - name: CUSTOM_LLM_MODEL
    valueFrom:
      secretKeyRef:
        name: email-rag-secrets
        key: custom-llm-model
        optional: true
  - name: DEFAULT_LLM_PROVIDER
    value: "openai"  # Change as needed
  - name: GROQ_MODEL
    value: "llama-3.3-70b-versatile"
  - name: CHROMA_PERSIST_DIRECTORY
    value: "/app/data/chroma"
  - name: UPLOAD_DIR
    value: "/app/data/uploads"  # Updated path
  - name: MAX_UPLOAD_SIZE_GB
    value: "50"
  # HuggingFace/Sentence-Transformers cache directory
  - name: HF_HOME
    value: "/app/data/models"
  - name: TRANSFORMERS_CACHE
    value: "/app/data/models"
  - name: SENTENCE_TRANSFORMERS_HOME
    value: "/app/data/models"
  - name: CORS_ORIGINS
    value: '["http://localhost:8080","http://localhost:5173","http://localhost:3000"]'

envLocal: []

configMap:
  globalEnv: ""
  localEnv: {}

secrets: {}  # Use external secret (see below)

configMapRef: []

secretRef:
  - name: email-rag-secrets

disable_configmap_local_env: false

## Container settings
args: []

## Security Context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: false  # Needed for ChromaDB and uploads

## Resources
## Adjust based on your workload
resources:
  limits:
    cpu: 2000m
    memory: 4Gi
  requests:
    cpu: 500m
    memory: 2Gi

## Node Selection
## Exclude GPU compute nodes
nodeSelector: {}

tolerations: []

affinity:
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
        - matchExpressions:
            - key: kubernetes.io/hostname
              operator: NotIn
              values:
                - ihc-gpu-compute-03  # Exclude this GPU node

topologySpreadConstraints: []

## Network settings
hostNetwork: false
dnsPolicy: "ClusterFirst"
dnsConfig: {}

## Volumes
## Not needed - using main persistence volume
volumes: []

volumeMounts: []

## Init containers - for database migrations and admin user creation
initContainers:
  - name: db-migration
    image: amiteshhsingh/email-rag-backend:v1.0.1
    command:
      - /bin/sh
      - -c
      - |
        echo "Running database migrations..."
        alembic upgrade head
        echo "Migrations completed successfully"
        
        echo "Creating admin user..."
        python3 -c "
        import asyncio, sys
        sys.path.insert(0, '/app')
        from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
        from sqlalchemy.orm import sessionmaker
        from sqlalchemy import select
        from app.db.models.user import User
        from app.core.security import get_password_hash
        from app.config import settings
        
        async def create_admin():
            engine = create_async_engine(settings.database_url, echo=False)
            async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
            async with async_session() as session:
                result = await session.execute(select(User).where(User.email == 'admin@example.com'))
                existing = result.scalar_one_or_none()
                if not existing:
                    session.add(User(
                        email='admin@example.com', username='admin',
                        hashed_password=get_password_hash('Admin123#'),
                        full_name='System Administrator',
                        role='admin', is_active=True, is_verified=True
                    ))
                    await session.commit()
                    print('Admin user created: admin@example.com / Admin123#')
                else:
                    print('Admin user already exists')
        asyncio.run(create_admin())
        "
        echo "Initialization complete"
    env:
      - name: DATABASE_URL
        valueFrom:
          secretKeyRef:
            name: email-rag-secrets
            key: database-url
      - name: REDIS_URL
        valueFrom:
          secretKeyRef:
            name: email-rag-secrets
            key: redis-url
      - name: CELERY_BROKER_URL
        valueFrom:
          secretKeyRef:
            name: email-rag-secrets
            key: celery-broker-url
      - name: SECRET_KEY
        valueFrom:
          secretKeyRef:
            name: email-rag-secrets
            key: secret-key
      - name: JWT_SECRET_KEY
        valueFrom:
          secretKeyRef:
            name: email-rag-secrets
            key: jwt-secret-key
    volumeMounts: []

## Prometheus / ServiceMonitor
serviceMonitor:
  enabled: false  # Enable if you have Prometheus Operator
  interval: 30s
  targetPort: http
  path: /metrics

extraVolumes: []
extraVolumeMounts: []
